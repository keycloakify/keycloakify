import "minimal-polyfills/Object.fromEntries";
import * as fs from "fs";
import { join as pathJoin, relative as pathRelative, dirname as pathDirname } from "path";
import { crawl } from "../src/bin/tools/crawl";
import { downloadBuiltinKeycloakTheme } from "../src/bin/download-builtin-keycloak-theme";
import { getProjectRoot } from "../src/bin/tools/getProjectRoot";
import { getCliOptions } from "../src/bin/tools/cliOptions";
import { getLogger } from "../src/bin/tools/logger";

//NOTE: To run without argument when we want to generate src/i18n/generated_kcMessages files,
// update the version array for generating for newer version.

//@ts-ignore
const propertiesParser = require("properties-parser");

const { isSilent } = getCliOptions(process.argv.slice(2));
const logger = getLogger({ isSilent });

(async () => {
    for (const keycloakVersion of ["11.0.3", "15.0.2", "18.0.1", "21.0.1"]) {
        logger.log(JSON.stringify({ keycloakVersion }));

        const tmpDirPath = pathJoin(getProjectRoot(), "tmp_xImOef9dOd44");

        fs.rmSync(tmpDirPath, { "recursive": true, "force": true });

        await downloadBuiltinKeycloakTheme({
            keycloakVersion,
            "destDirPath": tmpDirPath,
            isSilent
        });

        type Dictionary = { [idiomId: string]: string };

        const record: { [typeOfPage: string]: { [language: string]: Dictionary } } = {};

        {
            const baseThemeDirPath = pathJoin(tmpDirPath, "base");

            crawl(baseThemeDirPath).forEach(filePath => {
                const match = filePath.match(/^([^/]+)\/messages\/messages_([^.]+)\.properties$/);

                if (match === null) {
                    return;
                }

                const [, typeOfPage, language] = match;

                (record[typeOfPage] ??= {})[language.replace(/_/g, "-")] = Object.fromEntries(
                    Object.entries(propertiesParser.parse(fs.readFileSync(pathJoin(baseThemeDirPath, filePath)).toString("utf8"))).map(
                        ([key, value]: any) => [key, value.replace(/''/g, "'")]
                    )
                );
            });
        }

        fs.rmSync(tmpDirPath, { recursive: true, force: true });

        Object.keys(record).forEach(pageType => {
            const recordForPageType = record[pageType];

            Object.keys(recordForPageType).forEach(language => {
                const filePath = pathJoin(getProjectRoot(), "src", "lib", "i18n", "generated_messages", keycloakVersion, pageType, `${language}.ts`);

                fs.mkdirSync(pathDirname(filePath), { "recursive": true });

                fs.writeFileSync(
                    filePath,
                    Buffer.from(
                        [
                            `//This code was automatically generated by running ${pathRelative(getProjectRoot(), __filename)}`,
                            "//PLEASE DO NOT EDIT MANUALLY",
                            "",
                            "/* spell-checker: disable */",
                            `const messages= ${JSON.stringify(recordForPageType[language], null, 2)};`,
                            "",
                            "export default messages;",
                            "/* spell-checker: enable */"
                        ].join("\n"),
                        "utf8"
                    )
                );

                logger.log(`${filePath} wrote`);
            });
        });
    }
})();
